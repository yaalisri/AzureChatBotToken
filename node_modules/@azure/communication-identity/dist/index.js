'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var communicationCommon = require('@azure/communication-common');
var coreAuth = require('@azure/core-auth');
var coreHttp = require('@azure/core-http');
var api = require('@opentelemetry/api');
var logger$1 = require('@azure/logger');
var coreTracing = require('@azure/core-tracing');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const CommunicationIdentityCreateRequest = {
    type: {
        name: "Composite",
        className: "CommunicationIdentityCreateRequest",
        modelProperties: {
            createTokenWithScopes: {
                serializedName: "createTokenWithScopes",
                type: {
                    name: "Sequence",
                    element: { type: { name: "String" } }
                }
            }
        }
    }
};
const CommunicationIdentityAccessTokenResult = {
    type: {
        name: "Composite",
        className: "CommunicationIdentityAccessTokenResult",
        modelProperties: {
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentity"
                }
            },
            accessToken: {
                serializedName: "accessToken",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentityAccessToken"
                }
            }
        }
    }
};
const CommunicationIdentity = {
    type: {
        name: "Composite",
        className: "CommunicationIdentity",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CommunicationIdentityAccessToken = {
    type: {
        name: "Composite",
        className: "CommunicationIdentityAccessToken",
        modelProperties: {
            token: {
                serializedName: "token",
                required: true,
                type: {
                    name: "String"
                }
            },
            expiresOn: {
                serializedName: "expiresOn",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CommunicationErrorResponse = {
    type: {
        name: "Composite",
        className: "CommunicationErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CommunicationError"
                }
            }
        }
    }
};
const CommunicationError = {
    type: {
        name: "Composite",
        className: "CommunicationError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "CommunicationError" }
                    }
                }
            },
            innerError: {
                serializedName: "innerError",
                type: {
                    name: "Composite",
                    className: "CommunicationError"
                }
            }
        }
    }
};
const CommunicationIdentityAccessTokenRequest = {
    type: {
        name: "Composite",
        className: "CommunicationIdentityAccessTokenRequest",
        modelProperties: {
            scopes: {
                serializedName: "scopes",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "String" } }
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CommunicationIdentityCreateRequest: CommunicationIdentityCreateRequest,
    CommunicationIdentityAccessTokenResult: CommunicationIdentityAccessTokenResult,
    CommunicationIdentity: CommunicationIdentity,
    CommunicationIdentityAccessToken: CommunicationIdentityAccessToken,
    CommunicationErrorResponse: CommunicationErrorResponse,
    CommunicationError: CommunicationError,
    CommunicationIdentityAccessTokenRequest: CommunicationIdentityAccessTokenRequest
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: ["options", "body"],
    mapper: CommunicationIdentityCreateRequest
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-03-07",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const id = {
    parameterPath: "id",
    mapper: {
        serializedName: "id",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body1 = {
    parameterPath: "body",
    mapper: CommunicationIdentityAccessTokenRequest
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/**
 * Class representing a CommunicationIdentity.
 */
class CommunicationIdentity$1 {
    /**
     * Initialize a new instance of the class CommunicationIdentity class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Create a new identity.
     * @param options The options parameters.
     */
    create(options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ options: operationOptions }, createOperationSpec);
    }
    /**
     * Delete the identity, revoke all tokens for the identity and delete all associated data.
     * @param id Identifier of the identity to be deleted.
     * @param options The options parameters.
     */
    delete(id, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id, options: operationOptions }, deleteOperationSpec);
    }
    /**
     * Revoke all access tokens for the specific identity.
     * @param id Identifier of the identity.
     * @param options The options parameters.
     */
    revokeAccessTokens(id, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id, options: operationOptions }, revokeAccessTokensOperationSpec);
    }
    /**
     * Issue a new token for an identity.
     * @param id Identifier of the identity to issue token for.
     * @param body Requesting scopes for the new token.
     * @param options The options parameters.
     */
    issueAccessToken(id, body, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id, body, options: operationOptions }, issueAccessTokenOperationSpec);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
const createOperationSpec = {
    path: "/identities",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: CommunicationIdentityAccessTokenResult
        },
        default: {
            bodyMapper: CommunicationErrorResponse
        }
    },
    requestBody: body,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/identities/{id}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: CommunicationErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, id],
    serializer
};
const revokeAccessTokensOperationSpec = {
    path: "/identities/{id}/:revokeAccessTokens",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CommunicationErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, id],
    serializer
};
const issueAccessTokenOperationSpec = {
    path: "/identities/{id}/:issueAccessToken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CommunicationIdentityAccessToken
        },
        default: {
            bodyMapper: CommunicationErrorResponse
        }
    },
    requestBody: body1,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, id],
    headerParameters: [contentType],
    mediaType: "json",
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const packageName = "azure-communication-identity";
const packageVersion = "1.0.0";
class IdentityRestClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the IdentityRestClientContext class.
     * @param endpoint The communication resource, for example https://my-resource.communication.azure.com
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri = options.endpoint || "{endpoint}";
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2021-03-07";
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class IdentityRestClient extends IdentityRestClientContext {
    /**
     * Initializes a new instance of the IdentityRestClient class.
     * @param endpoint The communication resource, for example https://my-resource.communication.azure.com
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        super(endpoint, options);
        this.communicationIdentity = new CommunicationIdentity$1(this);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "1.0.0";

// Copyright (c) Microsoft Corporation.
/**
 * The \@azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("communication-identity");

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @internal
 */
const createSpan = coreTracing.createSpanFunction({
    packagePrefix: "Azure.Communication",
    namespace: "Microsoft.Communication"
});

// Copyright (c) Microsoft Corporation.
const isCommunicationIdentityClientOptions = (options) => options && !coreAuth.isTokenCredential(options) && !communicationCommon.isKeyCredential(options);
/**
 * Client class for interacting with Azure Communication Services User Token Management.
 */
class CommunicationIdentityClient {
    constructor(connectionStringOrEndpoint, credentialOrOptions, maybeOptions = {}) {
        const { url, credential } = communicationCommon.parseClientArguments(connectionStringOrEndpoint, credentialOrOptions);
        const options = isCommunicationIdentityClientOptions(credentialOrOptions)
            ? credentialOrOptions
            : maybeOptions;
        const libInfo = `azsdk-js-communication-identity/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        if (options.userAgentOptions.userAgentPrefix) {
            options.userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            options.userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info
            }
        });
        const authPolicy = communicationCommon.createCommunicationAuthPolicy(credential);
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new IdentityRestClient(url, pipeline).communicationIdentity;
    }
    /**
     * Creates a scoped user token.
     *
     * @param user - The user whose tokens are being issued.
     * @param scopes - Scopes to include in the token.
     * @param options - Additional options for the request.
     */
    getToken(user, scopes, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("CommunicationIdentity-issueToken", options);
            try {
                const _a = yield this.client.issueAccessToken(user.communicationUserId, { scopes }, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { _response } = _a, result = tslib.__rest(_a, ["_response"]);
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Revokes all data and tokens created for a user.
     *
     * @param user - The user whose tokens are being revoked.
     * @param options - Additional options for the request.
     */
    revokeTokens(user, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("CommunicationIdentity-revokeTokens", options);
            try {
                yield this.client.revokeAccessTokens(user.communicationUserId, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a single user.
     *
     * @param options - Additional options for the request.
     */
    createUser(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("CommunicationIdentity-createUser", options);
            try {
                const result = yield this.client.create(coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return {
                    communicationUserId: result.identity.id
                };
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Creates a single user and a token simultaneously.
     *
     * @param scopes - Scopes to include in the token.
     * @param options - Additional options for the request.
     */
    createUserAndToken(scopes, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("CommunicationIdentity-createUserAndToken", options);
            try {
                const { identity, accessToken } = yield this.client.create(Object.assign({ body: { createTokenWithScopes: scopes } }, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)));
                return Object.assign(Object.assign({}, accessToken), { user: { communicationUserId: identity.id } });
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Triggers revocation event for user and deletes all its data.
     *
     * @param user - The user being deleted.
     * @param options - Additional options for the request.
     */
    deleteUser(user, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("CommunicationIdentity-deleteUser", options);
            try {
                yield this.client.delete(user.communicationUserId, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
}

exports.CommunicationIdentityClient = CommunicationIdentityClient;
//# sourceMappingURL=index.js.map
